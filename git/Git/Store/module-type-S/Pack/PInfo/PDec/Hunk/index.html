<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Hunk (git.Git.Store.S.Pack.PInfo.PDec.Hunk)</title><link rel="stylesheet" href="../../../../../../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../../../../../../index.html">git</a> &#x00BB; <a href="../../../../../../index.html">Git</a> &#x00BB; <a href="../../../../../index.html">Store</a> &#x00BB; <a href="../../../../index.html">S</a> &#x00BB; <a href="../../../index.html">Pack</a> &#x00BB; <a href="../../index.html">PInfo</a> &#x00BB; <a href="../index.html">PDec</a> &#x00BB; Hunk</nav><h1>Module <code>PDec.Hunk</code></h1></header><div class="spec module" id="module-Hash"><a href="#module-Hash" class="anchor"></a><code><span class="keyword">module</span> <a href="Hash/index.html">Hash</a> : <a href="../../../../../../../Git__/S/index.html#module-type-HASH">Git__.S.HASH</a></code></div><dl><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">type</span> error</code><code> = </code><table class="variant"><tr id="type-error.Reserved_opcode" class="anchored"><td class="def constructor"><a href="#type-error.Reserved_opcode" class="anchor"></a><code>| </code><code><span class="constructor">Reserved_opcode</span> <span class="keyword">of</span> int</code></td><td class="doc"><p>Appear when we catch a reserved opcode.</p></td></tr><tr id="type-error.Wrong_copy_hunk" class="anchored"><td class="def constructor"><a href="#type-error.Wrong_copy_hunk" class="anchor"></a><code>| </code><code><span class="constructor">Wrong_copy_hunk</span> <span class="keyword">of</span> int * int * int</code></td><td class="doc"><p>Appear when the <code>Copy</code> hunk refers to a wrong area (because is bigger than it's possible to store into the target or because it does not correspond to a valid area from the source).</p></td></tr></table></dt><dd><p>The type error.</p></dd></dl><dl><dt class="spec value" id="val-pp_error"><a href="#val-pp_error" class="anchor"></a><code><span class="keyword">val</span> pp_error : <span><a href="index.html#type-error">error</a> Fmt.t</span></code></dt><dd><p>Pretty-printer of <a href="index.html#type-error"><code>error</code></a>.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code><code> = </code><code>{</code><table class="record"><tr id="type-t.i_off" class="anchored"><td class="def field"><a href="#type-t.i_off" class="anchor"></a><code>i_off : int;</code></td></tr><tr id="type-t.i_pos" class="anchored"><td class="def field"><a href="#type-t.i_pos" class="anchor"></a><code>i_pos : int;</code></td></tr><tr id="type-t.i_len" class="anchored"><td class="def field"><a href="#type-t.i_len" class="anchor"></a><code>i_len : int;</code></td></tr><tr id="type-t.read" class="anchored"><td class="def field"><a href="#type-t.read" class="anchor"></a><code>read : int;</code></td></tr><tr id="type-t._length" class="anchored"><td class="def field"><a href="#type-t._length" class="anchor"></a><code>_length : int;</code></td></tr><tr id="type-t._reference" class="anchored"><td class="def field"><a href="#type-t._reference" class="anchor"></a><code>_reference : <a href="index.html#type-reference">reference</a>;</code></td></tr><tr id="type-t._source_length" class="anchored"><td class="def field"><a href="#type-t._source_length" class="anchor"></a><code>_source_length : int;</code></td></tr><tr id="type-t._target_length" class="anchored"><td class="def field"><a href="#type-t._target_length" class="anchor"></a><code>_target_length : int;</code></td></tr><tr id="type-t._hunk" class="anchored"><td class="def field"><a href="#type-t._hunk" class="anchor"></a><code>_hunk : <span><a href="index.html#type-hunk">hunk</a> option</span>;</code></td></tr><tr id="type-t._tmp" class="anchored"><td class="def field"><a href="#type-t._tmp" class="anchor"></a><code>_tmp : Cstruct.t;</code></td></tr><tr id="type-t.state" class="anchored"><td class="def field"><a href="#type-t.state" class="anchor"></a><code>state : <a href="index.html#type-state">state</a>;</code></td></tr></table><code>}</code></dt><dd><p>The type of the Hunk decoder.</p></dd></dl><dl><dt class="spec type" id="type-k"><a href="#type-k" class="anchor"></a><code><span class="keyword">and</span> k</code><code> = Cstruct.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-res">res</a></code></dt><dt class="spec type" id="type-state"><a href="#type-state" class="anchor"></a><code><span class="keyword">and</span> state</code><code> = </code><table class="variant"><tr id="type-state.Header" class="anchored"><td class="def constructor"><a href="#type-state.Header" class="anchor"></a><code>| </code><code><span class="constructor">Header</span> <span class="keyword">of</span> <a href="index.html#type-k">k</a></code></td></tr><tr id="type-state.Stop" class="anchored"><td class="def constructor"><a href="#type-state.Stop" class="anchor"></a><code>| </code><code><span class="constructor">Stop</span></code></td></tr><tr id="type-state.List" class="anchored"><td class="def constructor"><a href="#type-state.List" class="anchor"></a><code>| </code><code><span class="constructor">List</span> <span class="keyword">of</span> <a href="index.html#type-k">k</a></code></td></tr><tr id="type-state.Is_insert" class="anchored"><td class="def constructor"><a href="#type-state.Is_insert" class="anchor"></a><code>| </code><code><span class="constructor">Is_insert</span> <span class="keyword">of</span> Cstruct.t * int * int</code></td></tr><tr id="type-state.Is_copy" class="anchored"><td class="def constructor"><a href="#type-state.Is_copy" class="anchor"></a><code>| </code><code><span class="constructor">Is_copy</span> <span class="keyword">of</span> <a href="index.html#type-k">k</a></code></td></tr><tr id="type-state.End" class="anchored"><td class="def constructor"><a href="#type-state.End" class="anchor"></a><code>| </code><code><span class="constructor">End</span></code></td></tr><tr id="type-state.Exception" class="anchored"><td class="def constructor"><a href="#type-state.Exception" class="anchor"></a><code>| </code><code><span class="constructor">Exception</span> <span class="keyword">of</span> <a href="index.html#type-error">error</a></code></td></tr></table></dt><dt class="spec type" id="type-res"><a href="#type-res" class="anchor"></a><code><span class="keyword">and</span> res</code><code> = </code><table class="variant"><tr id="type-res.Wait" class="anchored"><td class="def constructor"><a href="#type-res.Wait" class="anchor"></a><code>| </code><code><span class="constructor">Wait</span> <span class="keyword">of</span> <a href="index.html#type-t">t</a></code></td></tr><tr id="type-res.Error" class="anchored"><td class="def constructor"><a href="#type-res.Error" class="anchor"></a><code>| </code><code><span class="constructor">Error</span> <span class="keyword">of</span> <a href="index.html#type-t">t</a> * <a href="index.html#type-error">error</a></code></td></tr><tr id="type-res.Cont" class="anchored"><td class="def constructor"><a href="#type-res.Cont" class="anchor"></a><code>| </code><code><span class="constructor">Cont</span> <span class="keyword">of</span> <a href="index.html#type-t">t</a></code></td></tr><tr id="type-res.Ok" class="anchored"><td class="def constructor"><a href="#type-res.Ok" class="anchor"></a><code>| </code><code><span class="constructor">Ok</span> <span class="keyword">of</span> <a href="index.html#type-t">t</a> * <a href="index.html#type-hunks">hunks</a></code></td><td class="doc"><p>The type of compressed/delta-ified object.</p></td></tr></table></dt><dt class="spec type" id="type-hunk"><a href="#type-hunk" class="anchor"></a><code><span class="keyword">and</span> hunk</code><code> = </code><table class="variant"><tr id="type-hunk.Insert" class="anchored"><td class="def constructor"><a href="#type-hunk.Insert" class="anchor"></a><code>| </code><code><span class="constructor">Insert</span> <span class="keyword">of</span> Cstruct.t</code></td><td class="doc"><p>Raw buffer.</p></td></tr><tr id="type-hunk.Copy" class="anchored"><td class="def constructor"><a href="#type-hunk.Copy" class="anchor"></a><code>| </code><code><span class="constructor">Copy</span> <span class="keyword">of</span> int * int</code></td><td class="doc"><p>absolute offset ⨯ length</p></td></tr></table></dt><dt class="spec type" id="type-reference"><a href="#type-reference" class="anchor"></a><code><span class="keyword">and</span> reference</code><code> = </code><table class="variant"><tr id="type-reference.Offset" class="anchored"><td class="def constructor"><a href="#type-reference.Offset" class="anchor"></a><code>| </code><code><span class="constructor">Offset</span> <span class="keyword">of</span> int64</code></td></tr><tr id="type-reference.Hash" class="anchored"><td class="def constructor"><a href="#type-reference.Hash" class="anchor"></a><code>| </code><code><span class="constructor">Hash</span> <span class="keyword">of</span> <a href="index.html#module-Hash">Hash</a>.t</code></td><td class="doc"><p>The type of the Hunk.</p></td></tr></table></dt><dd><p>The type of the reference. It's a negative offset or the hash of the source object.</p></dd></dl><dl><dt class="spec type" id="type-hunks"><a href="#type-hunks" class="anchor"></a><code><span class="keyword">and</span> hunks</code><code> = </code><code>{</code><table class="record"><tr id="type-hunks.reference" class="anchored"><td class="def field"><a href="#type-hunks.reference" class="anchor"></a><code>reference : <a href="index.html#type-reference">reference</a>;</code></td><td class="doc"><p>Reference to the source.</p></td></tr><tr id="type-hunks.length" class="anchored"><td class="def field"><a href="#type-hunks.length" class="anchor"></a><code>length : int;</code></td><td class="doc"><p>Inflated length of the serialized Hunk.</p></td></tr><tr id="type-hunks.source_length" class="anchored"><td class="def field"><a href="#type-hunks.source_length" class="anchor"></a><code>source_length : int;</code></td><td class="doc"><p>Length of the source object.</p></td></tr><tr id="type-hunks.target_length" class="anchored"><td class="def field"><a href="#type-hunks.target_length" class="anchor"></a><code>target_length : int;</code></td><td class="doc"><p>Expected length of the target object.</p></td></tr></table><code>}</code></dt></dl><dl><dt class="spec value" id="val-partial_hunks"><a href="#val-partial_hunks" class="anchor"></a><code><span class="keyword">val</span> partial_hunks : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-hunks">hunks</a></code></dt><dd><p><code>partial_hunks t</code> returns a partial hunks to get some available information. <span class="xref-unresolved" title="unresolved reference to &quot;hunks.hunks&quot;"><a href="index.html#type-hunks"><code>hunks</code></a>.hunks</span> is not available.</p></dd></dl><dl><dt class="spec value" id="val-pp_reference"><a href="#val-pp_reference" class="anchor"></a><code><span class="keyword">val</span> pp_reference : <span><a href="index.html#type-reference">reference</a> Fmt.t</span></code></dt><dd><p>A pretty-printer of <a href="index.html#type-reference"><code>reference</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-pp_hunks"><a href="#val-pp_hunks" class="anchor"></a><code><span class="keyword">val</span> pp_hunks : <span><a href="index.html#type-hunks">hunks</a> Fmt.t</span></code></dt><dd><p>A pretty-printer of <a href="index.html#type-hunks"><code>hunks</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <span><a href="index.html#type-t">t</a> Fmt.t</span></code></dt><dd><p>Pretty-printer of the decoder <a href="index.html#type-t"><code>t</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-eval"><a href="#val-eval" class="anchor"></a><code><span class="keyword">val</span> eval : Cstruct.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>[ <span>`Hunk of <a href="index.html#type-t">t</a> * <a href="index.html#type-hunk">hunk</a></span> <span><span>| `Await</span> of <a href="index.html#type-t">t</a></span> <span><span>| `Error</span> of <a href="index.html#type-t">t</a> * <a href="index.html#type-error">error</a></span> <span><span>| `Ok</span> of <a href="index.html#type-t">t</a> * <a href="index.html#type-hunks">hunks</a></span> ]</span></code></dt><dd><p><code>eval src t</code> is:</p><ul><li><code>`Await t</code> iff <code>t</code> needs more input storage. The client must use <a href="index.html#val-refill"><code>refill</code></a> to provide a new buffer and then call <a href="index.html#val-eval"><code>eval</code></a> with <code>`Await</code> until other value returned.</li><li><code>`Hunk t</code> when <code>t</code> can return a new <a href="index.html#type-hunk"><code>hunk</code></a>. The client can call <a href="index.html#val-continue"><code>continue</code></a> to move to the next step of the process, otherwise the decode sticks on this situation. The value will be consumed then. If the <a href="index.html#type-hunk"><code>hunk</code></a> is <code>Insert</code>, the internal <code>Cstruct.t</code> need to be copied because <a href="index.html#val-eval"><code>eval</code></a> will erase the content then.</li><li><code>`Ok (t, hunks)</code> when <code>t</code> is done. We returns the complete value <a href="index.html#type-hunks"><code>hunks</code></a>. Then, <code>t</code> sticks on this situation, the client can remove it.</li><li><code>`Error (t, exn)</code> iff the decoder <code>t</code> meet an <a href="index.html#type-error"><code>error</code></a> <code>exn</code>. The decoder can't continue and sticks in this situation.</li></ul></dd></dl><dl><dt class="spec value" id="val-default"><a href="#val-default" class="anchor"></a><code><span class="keyword">val</span> default : int <span>&#45;&gt;</span> <a href="index.html#type-reference">reference</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Make a new decoder state <a href="index.html#type-t"><code>t</code></a> from a <a href="index.html#type-reference"><code>reference</code></a>. We need to notice the length of the inflated stream to know when the decoder <a href="index.html#type-t"><code>t</code></a> is done.</p></dd></dl><dl><dt class="spec value" id="val-refill"><a href="#val-refill" class="anchor"></a><code><span class="keyword">val</span> refill : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>refill off len t</code> provides a new <code>t</code> with <code>len</code> bytes to read, starting at <code>off</code>. This byte range is read by calls to <a href="index.html#val-eval"><code>eval</code></a> with <code>t</code> until <code>`Await</code> is returned.</p></dd></dl><dl><dt class="spec value" id="val-continue"><a href="#val-continue" class="anchor"></a><code><span class="keyword">val</span> continue : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>continue t</code> provides a new <code>t</code> to move to the next step of the process and consumes the current <a href="index.html#type-hunk"><code>hunk</code></a> returned by <a href="index.html#val-eval"><code>eval</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-current"><a href="#val-current" class="anchor"></a><code><span class="keyword">val</span> current : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-hunk">hunk</a></code></dt><dd><p><code>current t</code> provides the current <a href="index.html#type-hunk"><code>hunk</code></a> from the decoder <code>t</code>. This hunk is equivalent to: <code>eval _ t</code>, which returns <code>`Hunk</code> with the same (physically) <a href="index.html#type-hunk"><code>hunk</code></a>.</p><p>You only can call this function when you ensure than <code>eval _ t</code> returns <code>`Hunk</code>. Otherwise, we raise an exception <code>Invalid_argument</code>.</p></dd></dl><dl><dt class="spec value" id="val-used_in"><a href="#val-used_in" class="anchor"></a><code><span class="keyword">val</span> used_in : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>used_in ŧ</code> returns how many byte <code>t</code> consumed in the current buffer noticed to the previous call of <a href="index.html#val-eval"><code>eval</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-available_in"><a href="#val-available_in" class="anchor"></a><code><span class="keyword">val</span> available_in : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>available_in t</code> returns how many byte is available in the current buffer noticed to the previous call of <a href="index.html#val-eval"><code>eval</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-read"><a href="#val-read" class="anchor"></a><code><span class="keyword">val</span> read : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>read t</code> returns how many byte <code>t</code> read at the beginning. The client can assert than <code>read t</code> is equal to <code>length</code> noticed when he <code>make</code> the new decoder.</p></dd></dl></div></body></html>