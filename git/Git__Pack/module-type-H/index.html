<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>H (git.Git__Pack.H)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../../index.html">git</a> &#x00BB; <a href="../index.html">Git__Pack</a> &#x00BB; H</nav><h1>Module type <code>Git__Pack.H</code></h1><p>This module is the serialiser of the list of hunks in the PACK entry when we retrieve a delta-ified Git object. This encoder is a non-blocking encoder used in the same time than the <code>Deflater</code> - that means the content produced is always deflated.</p></header><div class="spec module" id="module-Hash"><a href="#module-Hash" class="anchor"></a><code><span class="keyword">module</span> <a href="Hash/index.html">Hash</a> : <a href="../../Git__/S/index.html#module-type-HASH">Git__.S.HASH</a></code></div><dl><dt class="spec type" id="type-error"><a href="#type-error" class="anchor"></a><code><span class="keyword">type</span> error</code></dt><dd><p>The type of error.</p></dd></dl><dl><dt class="spec value" id="val-pp_error"><a href="#val-pp_error" class="anchor"></a><code><span class="keyword">val</span> pp_error : <span><a href="index.html#type-error">error</a> Fmt.t</span></code></dt><dd><p>Pretty-printer of <a href="index.html#type-error"><code>error</code></a>.</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>The type of the encoder.</p></dd></dl><dl><dt class="spec type" id="type-reference"><a href="#type-reference" class="anchor"></a><code><span class="keyword">type</span> reference</code><code> = </code><table class="variant"><tr id="type-reference.Offset" class="anchored"><td class="def constructor"><a href="#type-reference.Offset" class="anchor"></a><code>| </code><code><span class="constructor">Offset</span> <span class="keyword">of</span> int64</code></td></tr><tr id="type-reference.Hash" class="anchored"><td class="def constructor"><a href="#type-reference.Hash" class="anchor"></a><code>| </code><code><span class="constructor">Hash</span> <span class="keyword">of</span> <a href="index.html#module-Hash">Hash</a>.t</code></td></tr></table></dt><dd><p>The type of the reference. It's a negative offset or the hash of the source object.</p></dd></dl><dl><dt class="spec value" id="val-pp"><a href="#val-pp" class="anchor"></a><code><span class="keyword">val</span> pp : <span><a href="index.html#type-t">t</a> Fmt.t</span></code></dt><dd><p>Pretty-printer of <a href="index.html#type-t"><code>t</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-default"><a href="#val-default" class="anchor"></a><code><span class="keyword">val</span> default : <a href="index.html#type-reference">reference</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <span>Duff.t list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Make a new encoder state <a href="index.html#type-t"><code>t</code></a> from a <a href="index.html#type-reference"><code>reference</code></a>. We need to notice the length of the inflated source and the length of the inflated target then, the compression list.</p></dd></dl><dl><dt class="spec value" id="val-refill"><a href="#val-refill" class="anchor"></a><code><span class="keyword">val</span> refill : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>refill off len t</code> provides a new <code>t</code> with <code>len</code> bytes to read, starting at <code>off</code>. This byte range is read by calls to <a href="index.html#val-eval"><code>eval</code></a> with <code>t</code> until <code>`Await</code> is returned. The encoder expects the target raw (not the source) to write <code>Insert</code> opcodes. The client must send the target raw continuously because internally, we assert than a continuous stream of the target raw and pick only the needed byte range.</p></dd></dl><dl><dt class="spec value" id="val-flush"><a href="#val-flush" class="anchor"></a><code><span class="keyword">val</span> flush : int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>flush off len t</code> provides <code>t</code> with <code>len</code> bytes to write, starting at <code>off</code>. This byte range is written by calls to <a href="index.html#val-eval"><code>eval</code></a> with <code>t</code> until <code>`Flush</code> is returned.</p></dd></dl><dl><dt class="spec value" id="val-finish"><a href="#val-finish" class="anchor"></a><code><span class="keyword">val</span> finish : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>finish t</code> provides a new <code>t</code> which does not expect any input. An <a href="index.html#val-eval"><code>eval</code></a> of the new <code>t</code> will never return an <code>`Await</code> value then.</p></dd></dl><dl><dt class="spec value" id="val-eval"><a href="#val-eval" class="anchor"></a><code><span class="keyword">val</span> eval : Cstruct.t <span>&#45;&gt;</span> Cstruct.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>[ <span>`Await of <a href="index.html#type-t">t</a></span> <span><span>| `Flush</span> of <a href="index.html#type-t">t</a></span> <span><span>| `End</span> of <a href="index.html#type-t">t</a></span> <span><span>| `Error</span> of <a href="index.html#type-t">t</a> * <a href="index.html#type-error">error</a></span> ]</span></code></dt><dd><p><code>eval src t</code> is:</p><ul><li><code>`Await t</code> iff <code>t</code> needs more input storage. The client must use <a href="index.html#val-refill"><code>refill</code></a> to provide a new buffer and then call <a href="index.html#val-eval"><code>eval</code></a> with <code>`Await</code> until other value returned.</li><li><code>`Flush t</code> iff <code>t</code> needs more output storage. The client must use <a href="index.html#val-flush"><code>flush</code></a> to provide a new buffer and then call <a href="index.html#val-eval"><code>eval</code></a> with <code>`Flush</code> until <code>`End</code> is returned.</li><li><code>`End t</code> when <code>t</code> is done. Then, <code>t</code> sticks on this situation, the client can remove it.</li><li><code>`Error (t, exn)</code> iff the encoder <code>t</code> meet an <a href="index.html#type-error"><code>error</code></a> <code>exn</code>. The encoder can't continue and sticks in this situation.</li></ul></dd></dl><dl><dt class="spec value" id="val-used_in"><a href="#val-used_in" class="anchor"></a><code><span class="keyword">val</span> used_in : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>used_in ŧ</code> returns how many byte <code>t</code> consumed in the current buffer noticed to the previous call of <a href="index.html#val-eval"><code>eval</code></a>.</p></dd></dl><dl><dt class="spec value" id="val-used_out"><a href="#val-used_out" class="anchor"></a><code><span class="keyword">val</span> used_out : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>used_out ŧ</code> returns how many byte <code>t</code> wrote in the current buffer noticed to the previous call of <a href="index.html#val-eval"><code>eval</code></a>.</p></dd></dl></div></body></html>