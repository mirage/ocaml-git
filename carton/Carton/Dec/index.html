<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Dec (carton.Carton.Dec)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">carton</a> &#x00BB; <a href="../index.html">Carton</a> &#x00BB; Dec</nav><header class="odoc-preamble"><h1>Module <code><span>Carton.Dec</span></code></h1><p>Decoder of a PACK file.</p><p>Along this module, the type <code>('a, 's) io</code> with a <code>'s scheduler</code> is needed for some operations (which use a <i>syscall</i>). To be able to use them, the use must create a new type <code>'s</code> which represents the scheduler. To do that with LWT for example:</p><pre class="language-ocaml"><code>module Lwt_scheduler = Make (Lwt)

let scheduler =
  let open Lwt.Infix in
  let open Lwt_scheduler in
  {
    bind = (fun x f -&gt; inj (x &gt;&gt;= fun x -&gt; prj (f x)));
    return = (fun x -&gt; inj x);
  }</code></pre><p>The produced module has 2 functions <code>inj</code> and <code>prj</code> to pass from or to an LWT value. The user can use these functions like:</p><pre class="language-ocaml"><code>let fiber =
  let ( &gt;&gt;= ) = scheduler.bind in
  let return = scheduler.return in

  weight_of_offset scheduler ~map t ~weight:null 0L &gt;&gt;= fun weight -&gt;
  let raw = make_raw ~weight in
  of_offset scheduler ~map t raw ~cursor:0L in
prj fiber ;;
- : (Carton.v, [&gt; error ]) Lwt.t = &lt;abstr&gt;</code></pre></header><nav class="odoc-toc"><ul><li><a href="#weight-of-object.">Weight of object.</a></li><li><a href="#value-of-object.">Value of object.</a></li><li><a href="#path-of-object.">Path of object.</a></li><li><a href="#uid-of-object.">Uid of object.</a></li><li><a href="#verify.">Verify.</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec module anchored" id="module-W"><a href="#module-W" class="anchor"></a><code><span><span class="keyword">module</span> <a href="W/index.html">W</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-weight"><a href="#type-weight" class="anchor"></a><code><span><span class="keyword">type</span> weight</span><span> = <span class="keyword">private</span> int</span></code></div><div class="spec-doc"><p>Type of <code>weight</code>. <code>weight</code> is <b>not</b> <i>length</i> of object but bytes needed to extract it.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-null"><a href="#val-null" class="anchor"></a><code><span><span class="keyword">val</span> null : <a href="#type-weight">weight</a></span></code></div><div class="spec-doc"><p><i>zero</i> weight.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-weight_of_int_exn"><a href="#val-weight_of_int_exn" class="anchor"></a><code><span><span class="keyword">val</span> weight_of_int_exn : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-weight">weight</a></span></code></div><div class="spec-doc"><p><code>weight_of_int_exn n</code> is the weight of <code>n</code>.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-read"><a href="#type-read" class="anchor"></a><code><span><span class="keyword">type</span> <span>('fd, 's) read</span></span><span> =
  <span><span class="type-var">'fd</span> <span class="arrow">&#45;&gt;</span></span>
  <span>bytes <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">off</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">len</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span>(int, <span class="type-var">'s</span>)</span> <span class="xref-unresolved">Carton__.Sigs.io</span></span></span></code></div><div class="spec-doc"><p>Type of read <i>syscall</i>.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Idx"><a href="#module-Idx" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Idx/index.html">Idx</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Fp"><a href="#module-Fp" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Fp/index.html">Fp</a></span><span> (<a href="Fp/argument-1-Uid/index.html">Uid</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>('fd, 'uid) t</span></span></code></div><div class="spec-doc"><p>Type of state used to access to any objects into a <code>Carton</code> file.</p></div></div><p>/</p><div class="odoc-spec"><div class="spec value anchored" id="val-header_of_entry"><a href="#val-header_of_entry" class="anchor"></a><code><span><span class="keyword">val</span> header_of_entry : 
  <span><span class="label">map</span>:<span><span class="type-var">'fd</span> <a href="W/index.html#type-map">W.map</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span>int64 <span class="arrow">&#45;&gt;</span></span>
  <span><a href="W/index.html#type-slice">W.slice</a> <span class="arrow">&#45;&gt;</span></span>
  int * int * int * <a href="W/index.html#type-slice">W.slice</a></span></code></div></div><p>/</p><div class="odoc-spec"><div class="spec value anchored" id="val-with_z"><a href="#val-with_z" class="anchor"></a><code><span><span class="keyword">val</span> with_z : <span><span class="xref-unresolved">Bigstringaf</span>.t <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>with_z new t</code> replaces the used temporary buffer by <code>t</code> by <code>new</code>. Indeed, when the user wants to extract an object, the internal temporary buffer is used to store the inflated object. By this way, a parallel/concurrent computation of 2 extractions with the same <code>t</code> is unsafe.</p><p>So, this function allows the user to create a <i>new</i> <code>t</code> with a new dedicated temporary buffer (physically different from the old one) to be able to start a parallel/concurrent process.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_w"><a href="#val-with_w" class="anchor"></a><code><span><span class="keyword">val</span> with_w : <span><span><span class="type-var">'fd</span> <a href="W/index.html#type-t">W.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>with_w w t</code> replaces the used table <a href="W/index.html#type-t"><code>W.t</code></a> by <code>w</code>. As <a href="#val-with_z"><code>with_z</code></a>, the purpose of this function is to be able to <i>parallelize</i> multiple <a href="#type-t"><code>t</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-with_allocate"><a href="#val-with_allocate" class="anchor"></a><code><span><span class="keyword">val</span> with_allocate : 
  <span><span class="label">allocate</span>:<span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">De</span>.window)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>with_allocate allocate t</code> replaces the function to allocate the window needed to inflate objects by <code>allocate</code>. As <a href="#val-with_z"><code>with_z</code></a>, the purpose of this function is to be able to <i>parallelize</i> multiple <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fd"><a href="#val-fd" class="anchor"></a><code><span><span class="keyword">val</span> fd : <span><span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'fd</span></span></code></div><div class="spec-doc"><p><code>fd t</code> returns the underlying used <code>fd</code> resource to map memory parts of it. On <code>Unix</code>, even if a mapped memory part can live if <code>fd</code> is the close, the resource should be open as long as the user extracts objects.</p></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-raw"><a href="#type-raw" class="anchor"></a><code><span><span class="keyword">type</span> raw</span></code></div><div class="spec-doc"><p>Type of a <code>Carton</code> object as is into a <code>Carton</code> file.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make_raw"><a href="#val-make_raw" class="anchor"></a><code><span><span class="keyword">val</span> make_raw : <span><span class="label">weight</span>:<a href="#type-weight">weight</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-raw">raw</a></span></code></div><div class="spec-doc"><p><code>make_raw ~weight</code> allocates a raw.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-weight_of_raw"><a href="#val-weight_of_raw" class="anchor"></a><code><span><span class="keyword">val</span> weight_of_raw : <span><a href="#type-raw">raw</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-weight">weight</a></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-v"><a href="#type-v" class="anchor"></a><code><span><span class="keyword">type</span> v</span></code></div><div class="spec-doc"><p>Type of values.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-v"><a href="#val-v" class="anchor"></a><code><span><span class="keyword">val</span> v : <span><span class="label">kind</span>:<span>[ `A <span>| `B</span> <span>| `C</span> <span>| `D</span> ]</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?depth</span>:int <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Bigstringaf</span>.t <span class="arrow">&#45;&gt;</span></span> <a href="#type-v">v</a></span></code></div><div class="spec-doc"><p><code>v ~kind ?depth raw</code> is a value <code>raw</code> typed by <code>kind</code>. <code>?depth</code> is an optional value to know at which depth the object exists into the PACK file it came from (default to <code>1</code>).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-kind"><a href="#val-kind" class="anchor"></a><code><span><span class="keyword">val</span> kind : <span><a href="#type-v">v</a> <span class="arrow">&#45;&gt;</span></span> <span>[ `A <span>| `B</span> <span>| `C</span> <span>| `D</span> ]</span></span></code></div><div class="spec-doc"><p><code>kind v</code> is the type of the object <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-raw"><a href="#val-raw" class="anchor"></a><code><span><span class="keyword">val</span> raw : <span><a href="#type-v">v</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Bigstringaf</span>.t</span></code></div><div class="spec-doc"><p><code>raw v</code> is the contents of the object <code>v</code>.</p><p><b>Note.</b> The <code>Bigstringaf.t</code> can be larger (and contain extra contents) than <code>len v</code> (see <a href="#val-len"><code>len</code></a>). The user should <code>Bigstringaf.sub</code> it with the real length of the object.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-len"><a href="#val-len" class="anchor"></a><code><span><span class="keyword">val</span> len : <span><a href="#type-v">v</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>len v</code> is the length of the object <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-depth"><a href="#val-depth" class="anchor"></a><code><span><span class="keyword">val</span> depth : <span><a href="#type-v">v</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>depth v</code> is the depth of the object into the PACK file it came from.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span><span class="keyword">val</span> copy : <span><span class="optlabel">?flip</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?weight</span>:<a href="#type-weight">weight</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-v">v</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-v">v</a></span></code></div><div class="spec-doc"><p><code>copy v</code> creates a fresh new object which is equal to the given <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : 
  <span><span class="type-var">'fd</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?sector</span>:int64 <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">z</span>:<span class="xref-unresolved">Zl</span>.bigstring <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">allocate</span>:<span>(<span>int <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Zl</span>.window)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">uid_ln</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">uid_rw</span>:<span>(<span>string <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'uid</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'uid</span> <span class="arrow">&#45;&gt;</span></span> int64)</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>make fd ~z ~allocate ~uid_ln ~uid_rw where</code> returns a state associated to <code>fd</code> which is the user-defined representation of a <code>Carton</code> file. Some informations are needed:</p><ul><li><code>z</code> is an underlying buffer used to <i>inflate</i> an object.</li><li><code>allocate</code> is an <i>allocator</i> of underlying <i>window</i> used to <i>inflate</i> an object.</li><li><code>uid_ln</code> is the length of <i>raw</i> representation of user-defined <i>uid</i>.</li><li><code>uid_rw</code> is the <i>cast-function</i> from a string to user-defined <i>uid</i>.</li><li><code>where</code> is the function to associate an <i>uid</i> to an <i>offset</i> into the associated <code>Carton</code> file.</li></ul><p>Each argument depends on what the user wants. For example, if <code>t</code> is used by <a href="Verify/index.html#val-verify"><code>Verify.verify</code></a>, <code>allocate</code> <b>must</b> be thread-safe according to <a href="../module-type-IO/index.html"><code>IO</code></a>. <code>where</code> is not used by <a href="Verify/index.html#val-verify"><code>Verify.verify</code></a>. <code>uid_ln</code> and <code>uid_rw</code> depends on the <code>Carton</code> file associated by <code>fd</code>. Each functions available below describes precisely what they do on <code>t</code>.</p></div></div><h4 id="weight-of-object."><a href="#weight-of-object." class="anchor"></a>Weight of object.</h4><p>Before to extract an object, we must know resources needed to extract it. <code>weight_of_offset</code>/<code>weight_of_uid</code> do an simple analyse and return the larger length needed to store the requested object such as:</p><pre class="language-ocaml"><code>weight_of_offset unix ~map t ~weight:null 0L &gt;&gt;= fun weight -&gt;
assert ((null :&gt; int) &lt;= (weight :&gt; int)) ;
Fmt.epr &quot;Object at %08Lx needs %d byte(s).\n%!&quot; 0L (weight :&gt; int) ;
let resource = make_raw ~weight in
...</code></pre><p>An object can need an other object (see <code>OBJ_OFS_DELTA</code> and <code>OBJ_REF_DELTA</code>). In this case, the resource needed must be larger/enough to store both objects. So the analyse is recursive over the <i>delta-chain</i>.</p><p><b>Note.</b> If the given PACK file represented by <code>t</code> is bad, <code>Cycle</code> is raised. It means that an object A refers to an object B which refers to our last object A.</p><p><b>Note.</b> This process is not <i>tail-rec</i> and discover at each step if it needs to continue the <i>delta-chain</i> or not.</p><div class="odoc-spec"><div class="spec exception anchored" id="exception-Cycle"><a href="#exception-Cycle" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Cycle</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-weight_of_offset"><a href="#val-weight_of_offset" class="anchor"></a><code><span><span class="keyword">val</span> weight_of_offset : 
  <span><span class="label">map</span>:<span><span class="type-var">'fd</span> <a href="W/index.html#type-map">W.map</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">weight</span>:<a href="#type-weight">weight</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?visited</span>:<span>int64 list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>int64 <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-weight">weight</a></span></code></div><div class="spec-doc"><p><code>weight_of_offset sched ~map t ~weight offset</code> returns the <code>weight</code> of the given object available at <code>offset</code> into <code>t</code>. This function assumes:</p><pre class="language-ocaml"><code>weight_of_offset sched ~map t ~weight:a offset &gt;&gt;= fun b -&gt;
assert ((a :&gt; int) &lt;= (b :&gt; int))</code></pre><p><b>Note.</b> This function can try to partially inflate objects. So, this function can use internal buffers and it is not <i>thread-safe</i>.</p><p><b>Note.</b> This function can try to <i>look-up</i> an other object if it extracts an <code>OBJ_REF_DELTA</code> object. However, if we suppose that we process a PACKv2, an <code>OBJ_REF_DELTA</code> <i>usually</i> points to an external object (see <i>thin</i>-pack).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-weight_of_uid"><a href="#val-weight_of_uid" class="anchor"></a><code><span><span class="keyword">val</span> weight_of_uid : 
  <span><span class="label">map</span>:<span><span class="type-var">'fd</span> <a href="W/index.html#type-map">W.map</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">weight</span>:<a href="#type-weight">weight</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?visited</span>:<span>int64 list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="type-var">'uid</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-weight">weight</a></span></code></div><div class="spec-doc"><p><code>weight_of_offset sched ~map t ~weight uid</code> returns the <code>weight</code> of the given object identified by <code>uid</code> into <code>t</code>. This function assumes the same assumption as <a href="#val-weight_of_offset"><code>weight_of_offset</code></a>.</p><p><b>Note.</b> As <a href="#val-weight_of_offset"><code>weight_of_offset</code></a>, this function can inflate objects and use internal buffers and it is not <i>thread-safe</i>.</p><p><b>Note.</b> Despite <a href="#val-weight_of_offset"><code>weight_of_offset</code></a>, this function <b>look-up</b> the object from the given reference.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-length_of_offset"><a href="#val-length_of_offset" class="anchor"></a><code><span><span class="keyword">val</span> length_of_offset : <span><span class="label">map</span>:<span><span class="type-var">'fd</span> <a href="W/index.html#type-map">W.map</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int64 <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><h4 id="value-of-object."><a href="#value-of-object." class="anchor"></a>Value of object.</h4><div class="odoc-spec"><div class="spec value anchored" id="val-of_offset"><a href="#val-of_offset" class="anchor"></a><code><span><span class="keyword">val</span> of_offset : <span><span class="label">map</span>:<span><span class="type-var">'fd</span> <a href="W/index.html#type-map">W.map</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-raw">raw</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">cursor</span>:int64 <span class="arrow">&#45;&gt;</span></span> <a href="#type-v">v</a></span></code></div><div class="spec-doc"><p><code>of_offset sched ~map raw ~cursor</code> is the object at the offset <code>cursor</code> into <code>t</code>. The function is not <i>tail-recursive</i>. It discovers at each step if the object depends on another one (see <code>OBJ_REF_DELTA</code> or <code>OBJ_OFS_DELTA</code>).</p><p><b>Note.</b> This function does not allocate larges resources (or, at least, only the given <code>allocate</code> function to <a href="#type-t"><code>t</code></a> is able to allocate a large resource). <code>raw</code> (which should be created with the associated <a href="#type-oracle.weight"><code>weight</code></a> given by <a href="#val-weight_of_offset"><code>weight_of_offset</code></a>) is enough to extract the object.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_uid"><a href="#val-of_uid" class="anchor"></a><code><span><span class="keyword">val</span> of_uid : <span><span class="label">map</span>:<span><span class="type-var">'fd</span> <a href="W/index.html#type-map">W.map</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-raw">raw</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'uid</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-v">v</a></span></code></div><div class="spec-doc"><p>As <a href="#val-of_offset"><code>of_offset</code></a>, <code>of_uid sched ~map raw uid</code> is the object identified by <code>uid</code> into <code>t</code>.</p></div></div><h4 id="path-of-object."><a href="#path-of-object." class="anchor"></a>Path of object.</h4><p>Due to the fact that <a href="#val-of_offset"><code>of_offset</code></a>/<a href="#val-of_uid"><code>of_uid</code></a> are not <i>tail-rec</i>, an other solution exists to extract an object from the PACK file. However, this solution requires a <i>meta-data</i> <a href="#type-path"><code>path</code></a> to be able to extract an object.</p><p>A <a href="#type-path"><code>path</code></a> is the <i>delta-chain</i> of the object. It assumes that a <i>delta-chain</i> can not be larger than <code>60</code> (see Git assumptions). From it, the way to construct an object is well-know and the step to discover if an object depends on an other one is deleted - and we ensure that the reconstruction is bound over our <a href="#type-path"><code>path</code></a>.</p><p>This solution fits well when we want to <i>memoize</i> the extraction.</p><div class="odoc-spec"><div class="spec type anchored" id="type-path"><a href="#type-path" class="anchor"></a><code><span><span class="keyword">type</span> path</span></code></div><div class="spec-doc"><p>The type of paths.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-path_to_list"><a href="#val-path_to_list" class="anchor"></a><code><span><span class="keyword">val</span> path_to_list : <span><a href="#type-path">path</a> <span class="arrow">&#45;&gt;</span></span> <span>int64 list</span></span></code></div><div class="spec-doc"><p><code>path_to_list path</code> returns the <i>delta-chain</i> of the given <code>path</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-kind_of_path"><a href="#val-kind_of_path" class="anchor"></a><code><span><span class="keyword">val</span> kind_of_path : <span><a href="#type-path">path</a> <span class="arrow">&#45;&gt;</span></span> <span>[ `A <span>| `B</span> <span>| `C</span> <span>| `D</span> ]</span></span></code></div><div class="spec-doc"><p><code>kind_of_path path</code> returns the kind of the object associated to the given <code>path</code>. An assumption exists about PACK format, a <i>delta-chain</i> refers to several objects which must have the same type/kind.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-path_of_offset"><a href="#val-path_of_offset" class="anchor"></a><code><span><span class="keyword">val</span> path_of_offset : <span><span class="label">map</span>:<span><span class="type-var">'fd</span> <a href="W/index.html#type-map">W.map</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="label">cursor</span>:int64 <span class="arrow">&#45;&gt;</span></span> <a href="#type-path">path</a></span></code></div><div class="spec-doc"><p><code>path_of_offset sched ~map t ~cursor</code> is that <a href="#type-path"><code>path</code></a> of the given object available at <code>cursor</code>.</p><p><b>Note.</b> This function can try to partially inflate objects. So, this function can use internal buffers and it is not <i>thread-safe</i>.</p><p><b>Note.</b> This function can try to <i>look-up</i> an other object if it extracts an <code>OBJ_REF_DELTA</code> object. However, if we suppose that we process a PACKv2, an <code>OBJ_REF_DELTA</code> <i>usually</i> points to an external object (see <i>thin</i>-pack).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-path_of_uid"><a href="#val-path_of_uid" class="anchor"></a><code><span><span class="keyword">val</span> path_of_uid : <span><span class="label">map</span>:<span><span class="type-var">'fd</span> <a href="W/index.html#type-map">W.map</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'uid</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-path">path</a></span></code></div><div class="spec-doc"><p><code>path_of_uid sched ~map t uid</code> is the <a href="#type-path"><code>path</code></a> of the given object identified by <code>uid</code> into <code>t</code>.</p><p><b>Note.</b> As <a href="#val-weight_of_offset"><code>weight_of_offset</code></a>, this function can inflate objects and use internal buffers and it is not <i>thread-safe</i>.</p><p><b>Note.</b> Despite <a href="#val-weight_of_offset"><code>weight_of_offset</code></a>, this function <b>look-up</b> the object from the given reference.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_offset_with_path"><a href="#val-of_offset_with_path" class="anchor"></a><code><span><span class="keyword">val</span> of_offset_with_path : 
  <span><span class="label">map</span>:<span><span class="type-var">'fd</span> <a href="W/index.html#type-map">W.map</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">path</span>:<a href="#type-path">path</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-raw">raw</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">cursor</span>:int64 <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-v">v</a></span></code></div><div class="spec-doc"><p><code>of_offset_with_path sched ~map t ~path raw ~cursor</code> is the object available at <code>cursor</code> into <code>t</code>. This function is <i>tail-recursive</i> and bound to the given <code>path</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-of_offset_with_source"><a href="#val-of_offset_with_source" class="anchor"></a><code><span><span class="keyword">val</span> of_offset_with_source : 
  <span><span class="label">map</span>:<span><span class="type-var">'fd</span> <a href="W/index.html#type-map">W.map</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-v">v</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">cursor</span>:int64 <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-v">v</a></span></code></div><div class="spec-doc"><p><code>of_offset_with_source ~map t ~path source ~cursor</code> is the object available at <code>cursor</code> into <code>t</code>. This function is <i>tail-recursive</i> and use the given <code>source</code> if the requested object is a patch.</p></div></div><h4 id="uid-of-object."><a href="#uid-of-object." class="anchor"></a>Uid of object.</h4><p>Unique identifier of objects is a user-defined type which is not described by the format of the PACK file. By this fact, the way to <i>digest</i> an object is at the user's discretion. For example, Git <i>prepends</i> the value by an header such as:</p><pre class="language-ocaml"><code>let digest v =
  let kind = match kind v with
    | `A -&gt; &quot;commit&quot;
    | `B -&gt; &quot;tree&quot;
    | `C -&gt; &quot;blob&quot;
    | `D -&gt; &quot;tag&quot; in
  let hdr = Fmt.str &quot;%s %d\000&quot; kind (len v) int
  let ctx = Digest.empty in
  feed_string ctx hdr ;
  feed_bigstring ctx (Bigstringaf.sub (raw v) 0 (len v)) ;
  finalize ctx</code></pre><p>Of course, the user can decide how to digest a value (see <a href="#type-oracle.digest"><code>digest</code></a>). However, 2 objects with the same contents but different types should have different unique identifier.</p><div class="odoc-spec"><div class="spec type anchored" id="type-digest"><a href="#type-digest" class="anchor"></a><code><span><span class="keyword">type</span> <span>'uid digest</span></span><span> =
  <span><span class="label">kind</span>:<span>[ `A <span>| `B</span> <span>| `C</span> <span>| `D</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?off</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?len</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="xref-unresolved">Bigstringaf</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'uid</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uid_of_offset"><a href="#val-uid_of_offset" class="anchor"></a><code><span><span class="keyword">val</span> uid_of_offset : 
  <span><span class="label">map</span>:<span><span class="type-var">'fd</span> <a href="W/index.html#type-map">W.map</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">digest</span>:<span><span class="type-var">'uid</span> <a href="#type-digest">digest</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-raw">raw</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">cursor</span>:int64 <span class="arrow">&#45;&gt;</span></span>
  <span>[ `A <span>| `B</span> <span>| `C</span> <span>| `D</span> ]</span> * <span class="type-var">'uid</span></span></code></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-uid_of_offset_with_source"><a href="#val-uid_of_offset_with_source" class="anchor"></a><code><span><span class="keyword">val</span> uid_of_offset_with_source : 
  <span><span class="label">map</span>:<span><span class="type-var">'fd</span> <a href="W/index.html#type-map">W.map</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">digest</span>:<span><span class="type-var">'uid</span> <a href="#type-digest">digest</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span>(<span class="type-var">'fd</span>, <span class="type-var">'uid</span>)</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">kind</span>:<span>[ `A <span>| `B</span> <span>| `C</span> <span>| `D</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-raw">raw</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">depth</span>:int <span class="arrow">&#45;&gt;</span></span>
  <span><span class="label">cursor</span>:int64 <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'uid</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-children"><a href="#type-children" class="anchor"></a><code><span><span class="keyword">type</span> <span>'uid children</span></span><span> = <span><span class="label">cursor</span>:int64 <span class="arrow">&#45;&gt;</span></span> <span><span class="label">uid</span>:<span class="type-var">'uid</span> <span class="arrow">&#45;&gt;</span></span> <span>int64 list</span></span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-where"><a href="#type-where" class="anchor"></a><code><span><span class="keyword">type</span> where</span><span> = <span><span class="label">cursor</span>:int64 <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec type anchored" id="type-oracle"><a href="#type-oracle" class="anchor"></a><code><span><span class="keyword">type</span> <span>'uid oracle</span></span><span> = </span><span>{</span></code><ol><li id="type-oracle.digest" class="def record field anchored"><a href="#type-oracle.digest" class="anchor"></a><code><span>digest : <span><span class="type-var">'uid</span> <a href="#type-digest">digest</a></span>;</span></code></li><li id="type-oracle.children" class="def record field anchored"><a href="#type-oracle.children" class="anchor"></a><code><span>children : <span><span class="type-var">'uid</span> <a href="#type-children">children</a></span>;</span></code></li><li id="type-oracle.where" class="def record field anchored"><a href="#type-oracle.where" class="anchor"></a><code><span>where : <a href="#type-where">where</a>;</span></code></li><li id="type-oracle.weight" class="def record field anchored"><a href="#type-oracle.weight" class="anchor"></a><code><span>weight : <span><span class="label">cursor</span>:int64 <span class="arrow">&#45;&gt;</span></span> <a href="#type-weight">weight</a>;</span></code></li></ol><code><span>}</span></code></div></div><h4 id="verify."><a href="#verify." class="anchor"></a>Verify.</h4><p>When the user get a PACK file, he must generate an IDX file (see <a href="Idx/index.html"><code>Idx</code></a>) from it - to be able to look-up objects from their <code>uid</code>. <code>Verify</code> is a process which try to create an OCaml representation of the IDX file. This process requires some information (see <a href="#type-oracle"><code>oracle</code></a>) which can be collected by a first analyse (see <a href="Fp/index.html"><code>Fp</code></a>). Then, the process wants to take the opportunity to <i>parallelize</i> extraction (depending on the <a href="../module-type-IO/index.html"><code>IO</code></a> implementation).</p><div class="odoc-spec"><div class="spec module anchored" id="module-Verify"><a href="#module-Verify" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Verify/index.html">Verify</a></span><span>
  (<a href="Verify/argument-1-Uid/index.html">Uid</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>)
  (<a href="Verify/argument-2-Scheduler/index.html">Scheduler</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>)
  (<a href="Verify/argument-3-IO/index.html">IO</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : 
  <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Ip"><a href="#module-Ip" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Ip/index.html">Ip</a></span><span>
  (<a href="Ip/argument-1-Scheduler/index.html">Scheduler</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>)
  (<a href="Ip/argument-2-IO/index.html">IO</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>)
  (<a href="Ip/argument-3-Uid/index.html">Uid</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span>) : 
  <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>
